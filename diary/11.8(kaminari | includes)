本日の課題はページネーション実装用gemのkatakuriの実装
並びに、それを踏まえてコントローラーを見た時に記述してた[@boards = Board.includes(:user)]という部分の理解度アップ

１、
先に後者の[includes]について

これは調べるとすぐ出るものの、まだ深掘りができていないN+1問題へのアンサー記述らしい

正しいかは別として調べてみた流れとしては内部処理的にざっくり言うと以下になる

クエリを呼び出す時に元々あった書き方ですると
クエリを呼び出す→実行→呼び出す→実行...→呼び出す→規定回数超えてたわ、実行は止めるね
という風に、規定回数を超えた事に気づくにはまず呼び出さなければいけない＝余計なクエリ実行が＋１起きちゃう、これって無駄だよねという話があった
(プラス、実行をリクエストされる度に上記のクエリ処理を呼び出していた（記述は省くけど、要はeach処理で呼び出していた）)

これを解消する為に誕生したのがincludes
処理的には
目的のクエリ情報を全て呼び出す→規定回数分を実行する
というモノになる

これだけだと利点薄くない？と正直なったけど、特に大事なのがキャッシュ維持の差（言い回しが違うかも）
前者の元々の書き方ですると毎回クエリを呼び出しているのに対して、
後者の書き方では取得した情報を保持して、以降呼び出さずに自前の情報から呼び出し処理を行ってくれる

クエリ呼び出しに使われるメモリの量を鑑みると、
1回目：前者＜後者
2回目以降：前者＞後者
のようになる。

具体的には、
1回目のincludes＞元々の処理(each)＞2回目以降のincludes
のようにeachは終始一律、includesは１回目こそ少し遅いが、2回目以降はincludesの方が処理が早い、という話になる


と、備忘録として長々書いた上で本題
今回気になっていたのが元々書いていた
@boards = Board.includes(:user)
という部分

こういう書き方をすればいいよ〜となっていたので書いたものの、
どういう意味合いなのかを理解し切れてなかった
なんとなく「Boardに関連付けがあるuserを呼び出してるんだな〜」程度の理解

AIに確認した結果をまとめると

・[Board]が主軸になっており、この部分に関してはBoard.allと同じ処理が起きている（Boardテーブルの全てを呼び出している）
・includesとしている事で、この主軸になっているBoardのレコードと関連があるuser情報を絞って取得している　（board情報が無いuserIDは省いている）

より具体的に言うと
Board.allとuser.find(board.user_id)が合わさった上で、一度のクエリで全てが処理される書き方
という意味になるみたい

こうやって分解してみると、ただincludesで覚えるよりも私は頭に入って来てくれた


２、
kaminariの実装について

今回はこちらの公式gemを流し読みしながら
https://github.com/kaminari/kaminari
こちらの見た目をよくする為のgem bootstrap5-kaminari-viewsの使い方を参考に実装
https://qiita.com/mocomou_/items/c3cce91c241e08f9a50b

ただ、これだけだと元々includesを書いていた部分を書き換えてしまっているので、
includesの状態に書き方を置き換えて実装したら上手く機能した。

少し迷ったのは１ページに表示する上限数を記述する場所
コントローラには記述するなとの指定があったので公式にあったようにモデルに記述をしたがNomethodエラーが出てしまった

なんでかな〜と思って色々みると、モデルで指定しているのは今回の場合あくまでページ数の指定をしているだけだったので
コントローラーにはちゃんとインスタンス内にページの情報を代入しておかないといけなかった
これだけで済むと思っていたから消してしまっていたので、
ちゃんと代入する内容に
page(params[:page])を追記した事で無事認識するようになり解決した。


色々と調べるキッカケにもなったし、そこまで詰まる事もなく満足できた。
