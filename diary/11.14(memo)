ひとまず先日から続いていた課題が終わったので記述する


１、セーフナビゲーション演算子（ぼっち演算子）
まず課題の解答例に記述されていたセーフナビゲーション演算子と呼ばれる部分
今回の課題内で元々使った記述が以下

@user.deliver_reset_password_instructions! if @user

リクエストされたインスタンスにデータが入っている場合、左の処理を実行する
という書き方になる

この書き方をする部分が出てくるのだが、解答例を見た所

@user&.deliver_reset_password_instructions!

という記述方法になっていた

これはどういう事？という事でAIくんに聞くと
「一つ目のコードで使われている @user&.deliver_reset_password_instructions! はセーフナビゲーション演算子と呼ばれるもので、
@user が nil であればメソッド呼び出しを行わず、nil でない場合のみ deliver_reset_password_instructions! メソッドを呼び出す。

二つ目のコードの if @user は、@user の存在を確認してからメソッドを呼び出すというより伝統的な書き方だ。

どちらの方法も、@user が nil の場合は deliver_reset_password_instructions! メソッドを呼び出さないという結果になるので、機能的には同じだね。」
との返答を頂いた。

ifでの記述は伝統的かつ明示的だが長い、
&.だけで済むのはよりコンパクトに済むが理解がないと可読性は低い、という一長一短があるみたい。

おさらいとして書くと
「[&.]は左側のオブジェクトがnilではない場合(データが入っている場合)、右の処理を実行する」
となる
まだ自分で使うかは別として、この読み方を理解しておく必要があるので覚えておきたい。



２、パラメータを取得することで出来ることがある

今回の課題を通してやっとHTTPリクエストの部分が少し読み解けるようになったので
備忘録として記述していく

今までの課題では例えば
@user = User.find(params[:id])
という風になっていて
中に入っている数字を見るとUser_idである1など、ただの数字が入っているだけだったので
そういうものなんだな、という認識だった

ところが今回の課題で初めて
@token = params[:id]
という参照テーブル名がないただのparamsをインスタンス化している記述があった

この記述が発火するのはパスワードの再発行依頼をし、届いたメールのURLへアクセスした瞬間になる。

その場合どうなるんだろうとこの時にbinding.pryでparams[:id]と記述すると
中には発行されたトークンが入っていた。この時点で今までの認識と全く異なるので、色々と確認。

順を追っていくと

１、パスワードを忘れてしまったメールアドレスを記入し、再発行依頼をする
  すると、そのリクエストを送った段階でコントローラーのcreateアクションが発火。
  送られてきたメールアドレスをDBに参照し、存在する場合はそのメールアドレスを有しているユーザーのレコードにあるreset_password_tokenというフィールドへ
  暗号化状態で作成されたトークンを登録する。

２、同時にメールを発信したユーザーへのアドレスへ向けて、今回のこのトークンをアクセス先に添えたURLを送信する
  このURLが肝心で、これこそがparams[:id]の発生元になる。


  このparams[:id]という記述だけにした場合、他の可能性もあるが今回に限ってはHTTPリクエストのID欄を参照する記述方法となる
  HTTPリクエストとは、いわゆるURLのこと。このparams[:id]が定義されているのはeditアクション内であり、それを踏まえた上で考える。

  ユーザーが送られてきたURLへアクセスするのだが、実際のURLは以下のようになっている
  [http://localhost:3000/password_resets/gu1oznR_H3TBzxBN5fxs/edit]
  
  これはrails routesで見るとわかるが、今回設定しているルーティングでは以下のようになっている
  edit_password_reset GET    /password_resets/:id/edit(.:format) password_resets#edit
  上記を並べると一目瞭然で、URLの[:id]部分がトークンに置き換わっているのだ。

  こちらから暗号化された状態のIDを発行しDBへ保存。
  ユーザーへそのIDを通達しそのページへアクセスし更新の手続きをする事で、DBに登録されたreset_password_tokenの持ち主のユーザーのPWが更新となる。
  専門用語的な言い方をすると、HTTPリクエスト欄の:id部分を参照する処理という言い方になるらしい。
  
  正直今までIDの部分は何となくでやっていた所があったが、改めて納得のいく処理として理解する事が出来た。


  余談（ある意味本題）だが、今回このIDが置き換わるのはセキュリティ上の問題へ対処する為の処置となる
  通常のやり方では今まで通りidは自動的に連番になるように登録されるため、
  見る人が見れば「URL欄のIDが数字になってる、ってことは数字を適当に入れれば別のURLにアクセス出来るのでは？」と考えるし、実際それが出来てしまう。

  そこで起きているのがこの暗号化されたIDとなり、
  PW再発行処理が依頼されて初めてIDが発行される上、連番ではないので他者からの故意的なアクセスも防ぐ事が出来るようになるという形
  

  正直、今回の課題ではこのIDに関しての部分を知識として染み込んだ感覚があるのが非常に大きい
  今までなぁなぁでやっていた部分が一気に紐付いて理解できたような感覚になれた。

  まだまだ不明点もあるものの、どちらかといえばgemの使用方法としての理解度の方なので今回は省略して次の課題へ進もうと思う

  





